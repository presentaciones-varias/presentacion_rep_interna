---
# title: "Mesa de Procesamiento REP"
# author: "Febrero 2024"
format:
  revealjs:
    auto-stretch: false
    margin: 0
    slide-number: true
    scrollable: true
    preview-links: auto
    logo: imagenes/logo_portada2.png
    css: ine_quarto_styles.css
    # footer: <https://quarto.org>
---

```{r librerias}
#| echo: FALSE
#| output: FALSE
#| eval: TRUE
library(dplyr)
library(targets)
library(kableExtra)
library(arrow)
library(janitor)
library(stringr)
library(ggplot2)

arrow::set_cpu_count(2)
options(arrow.use_threads = TRUE)
```

```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = '~/PCD/rep2/')
```

#

<!---
# TODO: this does not work
.linea-superior[]
.linea-inferior[] 
--->

<!---
# TODO: this does not work
![](imagenes/logo_portada2.png){.center style="width: 20%;"}   
--->

[]{.linea-superior} 
[]{.linea-inferior} 

<!---
<img src="imagenes/logo_portada2.png" style="width: 20%"/>  
--->

<img src="imagenes/logo_portada2.png" width="20%"/>  

[**Proyecto Estrat√©gico Registro Estad√≠stico de Poblaci√≥n (REP)**]{.big-par .center-justified}

[**Agosto 2024**]{.big-par .center-justified}

## Introducci√≥n 

<!---
## PE Servicios Compartidos  
--->

. . .

::: {.incremental .medium-par}

**Objetivo del REP:**

:::

. . . 

[*"Compilar datos de la poblaci√≥n permitiendo su conteo, localizaci√≥n y caracterizaci√≥n demogr√°fica b√°sica. Este permitir√° brindar acceso a datos poblacionales desagregados, oportunos y de calidad, derivando en la disminuci√≥n de costos asociados al levantamiento de datos. Adem√°s, la instalaci√≥n del REP permitir√° reducir las cargas en entrevistadores e informantes, entre otros beneficios.".*]{.medium-par}



## Introducci√≥n

::: {.incremental .medium-par}

- La construcci√≥n del REP se basa en el acceso a Registros Administrativos (RRAA).

- Actualmente contamos con tres RRAA nominados:

  - **Servicio de Registro Civil e Identificaci√≥n (SRCeI)**: 
  
    - Base amplia de informaci√≥n que incluye datos de identificaci√≥n, caracterizaci√≥n demogr√°fica (sexo, nacionalidad, fecha de nacimiento, fecha de defunci√≥n, estado civil, entre otros) y localizaci√≥n. 
    
    - La informaci√≥n del SRCeI se considera el punto de partida crucial para el REP.
  
  - **Fondo Nacional de Salud (FONASA)**:
  
    - El registro de FONASA es particularmente relevante para el proyecto REP dado que al contener informaci√≥n sobre los beneficiarios de la salud p√∫blica, abarca un universo de m√°s de 15 millones de personas por mes. 

    - Este registro no solo incluye personas con un RUN otorgado por el SRCeI, sino que puede contener personas a quienes a√∫n no se les haya otorgado este identificador. 
  
  - **Superintendencia de Seguridad Social (SUSESO)**:
  
    - Recopila antecedentes de varios temas, como de los trabajadores protegidos, cotizantes, pensionados y empresas

    - En el marco del REP, la tabla m√°s relevante en la exploraci√≥n es A01: **Trabajadores protegidos**, la que contiene el detalle de los antecedentes generales de todos los trabajadores cubiertos por dicho organismo administrador.


:::


## Procesamiento

::: {.incremental .medium-par}

1. Descarga ‚è≥

2. Deduplicaci√≥n ‚úÇÔ∏è

3. Obtener se√±ales de vida üëã

4. Vinculaci√≥n de las bases üîó

5. Limpieza üßπ

6. Construcci√≥n de variables relevantes: estado y condici√≥n de residencia üõ†Ô∏è

7. Conteos finales üë®‚Äçüë©‚Äçüëß‚Äçüë¶

:::

## Herramientas

::: {.incremental  layout-ncol=3}

![](imagenes/logo.svg){width=200}

![](imagenes/arrow-logo_hex_black-txt_white-bg.png){width=200}

![](imagenes/duckdb.png){width=200}

:::

## Herramientas: Targets üéØ

::: {.incremental .medium-par}

- Targets es un paquete de gesti√≥n de flujos de trabajo para el lenguaje de programaci√≥n R. 

- Targets acelera el an√°lisis con computaci√≥n paralela f√°cil de configurar, mejora la reproducibilidad y reduce la carga de c√°lculos repetidos y la micromanipulaci√≥n manual de datos.

- Evita tener que...

  - Inciar el c√≥digo 
  
  - Esperar mientras corre
  
  - Descubrir un problema
  
  - Reiniciar desde cero üò±
  
- Veamos un ejemplo

:::

::: notes

- En este ejemplo se hace an√°lisis breve para establecer la relaci√≥n entre el ozono y la temperatura.

- Para utilizar targets es necesario tener el script llamado _targets. En este script es donde vamos a configurar a describir el pipeline

- Es necesario llamar el paquete targets al comienzo del script

- En tar_option_set definimos los paquetes que se van a usar, entre otras configuraciones como el formato de almacenamiento, computaci√≥n paralela, etc

- Luego es necesario cargar las funciones que se van a utilizar. Esto se puede hacer con tar_source() si la carpeta donde est√°n las funciones se llama R o con un list.files y luego aplicar un source de la manera tradicional

- Luego definimos el pipeline que es una lista de targets donde cada target es un paso en el an√°lisis

- Cada target tiene un nombre y se crean usando la funci√≥n tar_target

- En el target file declaramos format = "file" para decirle a targets que ese target es un archivo externo y deber√≠a actualizarse si el contenido del archvio cambia 

- Vemos que los argumentos de las funciones son el nombre de los otros targets.

- Podemos correr tar_manifest para ver que los targets est√°n correctos

- Luego podemos ver el gr√°fico de dependencia del pipeline con tar_visnetwork. Si existen muchos targets esta funci√≥n puede correr lento.

- Finalmente, podemos correr el pipeline usando tar_make() que corre todos los targets en orden y guarda los resultados en la carpeta _targets/objects.

- Podemos acceder a los resultados usando tar_read()

- Si corro tar_make() de nuevo y nada cambia targets se salta todo

- Si quiero hacer un cambio en alguna funci√≥n intermedia, targets va a correr solamente los targets que est√°n conectados con esa funci√≥n


:::

## Herramientas: Arrow üèπ

::: {.incremental .medium-par}

- El paquete Arrow en R es parte del ecosistema Apache Arrow, una plataforma de desarrollo para la gesti√≥n de datos en memoria que est√° dise√±ada para ser altamente eficiente en t√©rminos de rendimiento y compatibilidad entre diferentes lenguajes de programaci√≥n.

- Arrow permite...

  - Manipulaci√≥n eficiente de datos en memoria

  - Lectura y escritura de formatos de datos eficientes

  - Consulta y filtrado eficiente de datos
  
  - Pasar datos hacia y desde DuckDB

:::

. . . 

```{r}
#| echo: true
#| eval: false
data <- data %>% 
  to_duckdb() %>% 
  slice_sample(n = 1, by = run_dv) %>% 
  to_arrow() %>% 
  compute()
```


## Herramientas: DuckDB ü¶Ü

::: {.incremental .medium-par}

- DuckDB es un motor de base de datos anal√≠tico r√°pido y liviano que est√° dise√±ado para funcionar con varios lenguajes de programaci√≥n, incluido R. 

- Est√° dise√±ado para ser utilizado directamente desde el c√≥digo, sin necesidad de instalar un servidor de base de datos independiente.

- Permite ejecutar consultas sobre conjuntos de datos que no caben en la memoria utilizando herramientas familiares de an√°lisis de datos.

- Veamos un ejemplo:

:::

## Herramientas: DuckDB ü¶Ü

```{r}
#| echo: true
#| eval: false
deduplicate_rc_by_name_dob <- function(data) {
  
  print("Cargar datos...")
  
  data <- as_arrow_table(data)
  
  # Crear conexi√≥n DB
  con <- dbConnect(duckdb::duckdb(), dbdir = "data/edited/rep.db", read_only = FALSE)
  
  # Registrar el objeto Arrow como una tabla virtual y crear la tabla DuckDb de esta tabla
  arrow::to_duckdb(data, table_name = "rc_deduplicated_by_run", con = con)
  
  dbSendQuery(con, "CREATE TABLE rc_deduplicated_by_run AS SELECT * FROM rc_deduplicated_by_run")
  
  rm(data)
  
  data <- tbl(con, "rc_deduplicated_by_run")
  
  print("Deduplicar...")
  
  data <- data %>% 
    group_by(nombre_paste_rc, fecha_nac_rc) %>% 
    slice_max(run_dv) %>% 
    ungroup() %>% 
    compute()
  
  data <- data %>% to_arrow()
  data <- data %>% as_arrow_table()
  
  dbDisconnect(con)
  
  file.remove("data/edited/rep.db")
  
  data
  
}
```

::: notes
- Esta es una funci√≥n utilizada para deduplicar el RC usando el nombre y la fecha de nacimiento

- El primer paso es cargar la base del RC y convertirla en una tabla arrow

- Para utilizar DuckDB, primero hay que crear un objeto de conexi√≥n que represente la base de datos. El objeto de conexi√≥n toma como par√°metro el archivo de base de datos para leer y escribir. Si el archivo de base de datos no existe, se crear√° (la extensi√≥n del archivo puede ser .db, .duckdb o cualquier otra).

- Luego guardamos el objeto Arrow como una tabla virtual DuckDB, d√°ndole un nombre que ser√° utilizado en la consulta SQL, finalmente ejecutamos la consulta para crear al tabla.
:::

## Conteos finales üë®‚Äçüë©‚Äçüëß‚Äçüë¶

::: {.incremental .medium-par}

- Todo muy interesante pero...

- Cu√°ntos somos?! üò±

- Depende... ü§î

:::

. . . 

::: {.incremental .medium-par}

```{r tbl10}
tbl10 <- read_parquet("presentations/presentacion-rep-interna/tablas/tbl10.parquet")
tbl10 %>% kbl()
```

:::

::: notes

- Una persona se clasifica como "viva" si no tiene fecha de defunci√≥n, no es outlier y tiene un run v√°lido.

- Una persona se clasifica como "muerta" si tiene fecha de defunci√≥n, si no tiene fecha de defunci√≥n pero es outlier o si no tiene fecha de defunci√≥n pero tiene un run inv√°lido.

- Finalmente, una persona se clasifica como "incierta" cuando no hizo match con el RC y cuando no tiene se√±ales de vida en suseso o en fonasa

:::

## Conteos finales üë®‚Äçüë©‚Äçüëß‚Äçüë¶

:::: {layout-ncol=2}

::: {.fragment .small-par .center}
 
```{r tbl11}
#| tbl-cap: Vivos activos
tbl11 <- read_parquet("presentations/presentacion-rep-demografia/tablas/tbl11.parquet")
tbl11 %>% kbl()
```
::: 

::: {.fragment .small-par .center}
```{r tbl12}
#| tbl-cap: Vivos activos m√°s sin se√±al
tbl12 <- read_parquet("presentations/presentacion-rep-demografia/tablas/tbl12.parquet")
tbl12 %>% kbl()
```

:::


::: {.fragment .small-par .center}
 
![Vivos activos](imagenes/edad_sexo_plot_1.png)

::: 

::: {.fragment .small-par .center}

![Vivos activos m√°s sin se√±al](imagenes/edad_sexo_plot_2.png)

:::


::::

